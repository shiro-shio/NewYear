<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>2025 Realistic Anime Fireworks</title>
<style>
    body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
    #ui-container {
        position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
        text-align: center; z-index: 100; pointer-events: none;
        color: rgba(255,255,255,0.9); text-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    #countdown { font-size: 4rem; font-weight: 200; letter-spacing: 2px; margin-bottom: 10px; font-variant-numeric: tabular-nums; }
    #controls { pointer-events: auto; background: rgba(255,255,255,0.1); backdrop-filter: blur(8px); padding: 10px 20px; border-radius: 30px; display: inline-block; border: 1px solid rgba(255,255,255,0.2); }
    button { background: transparent; border: 1px solid rgba(255,255,255,0.4); color: white; padding: 5px 15px; border-radius: 15px; cursor: pointer; transition: 0.3s; }
    button:hover { background: rgba(255,255,255,0.2); border-color: white; }
    .label { font-size: 0.8rem; margin-right: 10px; opacity: 0.8; }
</style>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>
</head>
<body>

<div id="ui-container">
    <div id="countdown">00:00:00</div>
    <div id="controls">
        <span class="label">2025 æ–°å¹´å€’æ•¸</span>
        <button id="btn-sound">ğŸ”Š é–‹å•ŸéŸ³æ•ˆ (æ¨¡æ“¬)</button>
        <button id="btn-launch" onclick="launchManual()">ğŸš€ ç™¼å°„ç…™ç«</button>
    </div>
</div>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ==========================================
// 1. å ´æ™¯èˆ‡å¾Œè™•ç†è¨­å®š (æ ¸å¿ƒç•«è³ªä¾†æº)
// ==========================================
const scene = new THREE.Scene();
// æ·»åŠ å¾®å¼±çš„éœ§æ°£è®“é è™•ç…™ç«æœ‰æ™¯æ·±æ„Ÿ
scene.fog = new THREE.FogExp2(0x000000, 0.002);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 100);
camera.lookAt(0, 20, 0);

const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // å„ªåŒ–æ•ˆèƒ½
renderer.toneMapping = THREE.ReinhardToneMapping;
document.body.appendChild(renderer.domElement);

// --- Bloom (æ³›å…‰) è¨­å®š ---
// é€™æ˜¯è®“ç…™ç«çœ‹èµ·ä¾†ã€Œç¾ã€çš„é—œéµï¼ŒæŠŠäº®éƒ¨æ¸²æŸ“å¾—åƒéœ“è™¹ç‡ˆ
const renderScene = new RenderPass(scene, camera);
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
bloomPass.strength = 2.5; // å…‰æšˆå¼·åº¦
bloomPass.radius = 0.8;   // å…‰æšˆæ“´æ•£ç¯„åœ
bloomPass.threshold = 0.1; // äº®åº¦é–¾å€¼

const composer = new EffectComposer(renderer);
composer.addPass(renderScene);
composer.addPass(bloomPass);

// ==========================================
// 2. è³‡æºç”Ÿæˆ (ç¨‹å¼åŒ–è²¼åœ–)
// ==========================================
function createGlowTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
    gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0,0,32,32);
    const texture = new THREE.CanvasTexture(canvas);
    return texture;
}
const particleTexture = createGlowTexture();

// ==========================================
// 3. ç…™ç«ç³»çµ±æ ¸å¿ƒé‚è¼¯
// ==========================================
const fireworks = [];

// é…è‰²ç›¤ (HSL)
const colors = [
    { h: 0, s: 100, l: 60 },    // ç´…
    { h: 30, s: 100, l: 60 },   // æ©™
    { h: 60, s: 100, l: 60 },   // é‡‘
    { h: 120, s: 100, l: 60 },  // ç¶ 
    { h: 180, s: 100, l: 60 },  // é’
    { h: 240, s: 100, l: 70 },  // è—
    { h: 300, s: 100, l: 60 },  // ç´«
];

class Firework {
    constructor(startX, targetY) {
        this.isDead = false;
        this.phase = 'launch'; // launch (å‡ç©º) -> explode (çˆ†ç‚¸)
        
        // è¨­å®šé¡è‰²
        const baseColor = colors[Math.floor(Math.random() * colors.length)];
        this.color = new THREE.Color().setHSL(baseColor.h/360, baseColor.s/100, baseColor.l/100);
        
        // --- å‡ç©ºéšæ®µè¨­å®š ---
        this.pos = new THREE.Vector3(startX, -40, 0); // å¾ç•«é¢ä¸‹æ–¹é–‹å§‹
        this.vel = new THREE.Vector3(0, (Math.random() * 0.5 + 1.2), 0); // å‘ä¸Šé€Ÿåº¦
        this.targetY = targetY + (Math.random() * 10 - 5);
        
        // å»ºç«‹å‡ç©ºç²’å­ (Rocket)
        const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0)]);
        const mat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1.5,
            map: particleTexture,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        this.rocket = new THREE.Points(geo, mat);
        this.rocket.position.copy(this.pos);
        scene.add(this.rocket);

        // --- çˆ†ç‚¸ç²’å­ç¾¤ (é å…ˆå®šç¾©ï¼Œä½†æš«æ™‚éš±è—) ---
        this.particles = null; 
        this.geometry = null;
    }

    update() {
        if (this.phase === 'launch') {
            // ç‰©ç†ç§»å‹•
            this.pos.add(this.vel);
            this.rocket.position.copy(this.pos);

            // éš¨æ©ŸæŠ–å‹•æ¨¡æ“¬é¢¨é˜»
            this.pos.x += (Math.random() - 0.5) * 0.1;

            // æ‹–å°¾æ•ˆæœ (ç°¡å–®æ¨¡æ“¬ï¼šåœ¨ç•¶å‰ä½ç½®ç”¢ç”Ÿä¸€å€‹å¿«é€Ÿæ¶ˆå¤±çš„å°é»ï¼Œé€™è£¡çœç•¥ä»¥ä¿æ•ˆèƒ½ï¼Œæ”¹ç”¨ Bloom å¢å¼·è¦–è¦ºæ®˜ç•™)

            // æª¢æŸ¥æ˜¯å¦åˆ°é”é ‚é»
            if (this.vel.y > 0.1 && this.pos.y < this.targetY) {
                this.vel.y *= 0.98; // æ¸›é€Ÿ
            } else {
                this.explode();
            }
        } 
        else if (this.phase === 'explode') {
            const positions = this.geometry.attributes.position.array;
            
            // æ›´æ–°æ¯ä¸€å€‹çˆ†ç‚¸ç²’å­
            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                
                // é€Ÿåº¦æ‡‰ç”¨
                positions[i3] += this.velocities[i3];
                positions[i3+1] += this.velocities[i3+1];
                positions[i3+2] += this.velocities[i3+2];

                // é‡åŠ›èˆ‡é˜»åŠ›
                this.velocities[i3+1] -= 0.015; // é‡åŠ›
                this.velocities[i3] *= 0.96;    // ç©ºæ°£é˜»åŠ›
                this.velocities[i3+1] *= 0.96;
                this.velocities[i3+2] *= 0.96;
            }
            
            this.geometry.attributes.position.needsUpdate = true;
            
            // æ¼¸éš±
            this.material.opacity -= 0.012;
            this.material.size *= 0.99; // ç²’å­æ…¢æ…¢è®Šå°
            
            if (this.material.opacity <= 0) {
                this.isDead = true;
                scene.remove(this.particles);
                this.geometry.dispose();
                this.material.dispose();
            }
        }
    }

    explode() {
        this.phase = 'explode';
        scene.remove(this.rocket); // ç§»é™¤å‡ç©ºç«ç®­

        // å»ºç«‹çˆ†ç‚¸å¹¾ä½•é«”
        this.count = 400 + Math.floor(Math.random() * 300); // ç²’å­æ•¸é‡
        this.geometry = new THREE.BufferGeometry();
        this.velocities = new Float32Array(this.count * 3);
        const positions = new Float32Array(this.count * 3);
        const colorsArr = new Float32Array(this.count * 3);

        for (let i = 0; i < this.count; i++) {
            // çƒå½¢çˆ†ç‚¸ç®—æ³• (Spherical distribution)
            const r = Math.random() * 0.5 + 0.1; // çˆ†ç‚¸åˆå§‹åŠå¾‘
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            
            // åˆå§‹ä½ç½® (ç¨å¾®åˆ†æ•£åœ¨ä¸­å¿ƒ)
            positions[i*3] = this.pos.x + r * Math.sin(phi) * Math.cos(theta);
            positions[i*3+1] = this.pos.y + r * Math.sin(phi) * Math.sin(theta);
            positions[i*3+2] = this.pos.z + r * Math.cos(phi);

            // çˆ†ç‚¸é€Ÿåº¦ (Power)
            const power = Math.random() * 1.5 + 0.5;
            this.velocities[i*3] = Math.sin(phi) * Math.cos(theta) * power;
            this.velocities[i*3+1] = Math.sin(phi) * Math.sin(theta) * power;
            this.velocities[i*3+2] = Math.cos(phi) * power;

            // é¡è‰²è®Šç•° (è®“æ¯å€‹ç²’å­é¡è‰²ç¨å¾®ä¸åŒï¼Œæ›´è±å¯Œ)
            const colorVar = this.color.clone().offsetHSL(0, 0, (Math.random()-0.5)*0.2);
            colorsArr[i*3] = colorVar.r;
            colorsArr[i*3+1] = colorVar.g;
            colorsArr[i*3+2] = colorVar.b;
        }

        this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.geometry.setAttribute('color', new THREE.BufferAttribute(colorsArr, 3));

        this.material = new THREE.PointsMaterial({
            size: 2.5,
            map: particleTexture,
            vertexColors: true,
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending, // é—œéµï¼šåŠ æ³•æ··åˆè®“é‡ç–Šè™•è®Šäº®
            depthWrite: false
        });

        this.particles = new THREE.Points(this.geometry, this.material);
        scene.add(this.particles);
        
        // ç°¡æ˜“é–ƒå…‰ (Flash)
        createFlash(this.pos, this.color);
    }
}

// çˆ†ç‚¸ç¬é–“çš„é–ƒå…‰çƒé«” (è®“è¦–è¦ºè¡æ“Šæ›´å¼·)
function createFlash(pos, color) {
    const geo = new THREE.SphereGeometry(1, 16, 16);
    const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.copy(pos);
    scene.add(mesh);
    
    // ç¨ç«‹çš„é–ƒå…‰å‹•ç•«é‚è¼¯
    const animateFlash = () => {
        mesh.scale.multiplyScalar(1.2); // å¿«é€Ÿè®Šå¤§
        mesh.material.opacity *= 0.85;  // å¿«é€Ÿæ¶ˆå¤±
        if (mesh.material.opacity < 0.01) {
            scene.remove(mesh);
            geo.dispose();
            mat.dispose();
        } else {
            requestAnimationFrame(animateFlash);
        }
    };
    animateFlash();
}


// ==========================================
// 4. å‹•ç•«è¿´åœˆ
// ==========================================
function animate() {
    requestAnimationFrame(animate);

    // æ¸…ç†çµæŸçš„ç…™ç«
    for (let i = fireworks.length - 1; i >= 0; i--) {
        fireworks[i].update();
        if (fireworks[i].isDead) {
            fireworks.splice(i, 1);
        }
    }

    // ä½¿ç”¨ composer æ¸²æŸ“ Bloom æ•ˆæœ
    composer.render();
}
animate();

// ==========================================
// 5. äº’å‹•èˆ‡å€’æ•¸é‚è¼¯
// ==========================================
window.launchManual = () => {
    // x ç¯„åœ -40 ~ 40, y é«˜åº¦ 20 ~ 40
    const x = (Math.random() - 0.5) * 80;
    const y = 20 + Math.random() * 20;
    fireworks.push(new Firework(x, y));
};

// è‡ªå‹•æ–½æ”¾é‚è¼¯
let autoInterval = null;
function startAutoFire() {
    if(autoInterval) return;
    autoInterval = setInterval(() => {
        launchManual();
        // æœ‰æ©Ÿç‡ä¸€æ¬¡æ”¾å…©ç™¼
        if(Math.random() > 0.7) setTimeout(launchManual, 200);
    }, 800);
}

// å€’æ•¸è¨ˆæ™‚
const countdownEl = document.getElementById('countdown');
const targetDate = new Date(new Date().getFullYear() + 1, 0, 1); // æ˜å¹´ 1/1

function updateCountdown() {
    const now = new Date();
    const diff = targetDate - now;

    if (diff <= 0) {
        countdownEl.innerText = "2025 HAPPY NEW YEAR";
        startAutoFire();
        return;
    }

    const h = String(Math.floor(diff / 3600000)).padStart(2, '0');
    const m = String(Math.floor((diff % 3600000) / 60000)).padStart(2, '0');
    const s = String(Math.floor((diff % 60000) / 1000)).padStart(2, '0');
    countdownEl.innerText = `${h}:${m}:${s}`;
}
setInterval(updateCountdown, 1000);

// RWD
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});

// éŸ³æ•ˆæ§åˆ¶ (ç°¡å–®æ¨¡æ“¬)
let soundEnabled = false;
document.getElementById('btn-sound').addEventListener('click', (e) => {
    soundEnabled = !soundEnabled;
    e.target.innerText = soundEnabled ? "ğŸ”Š éŸ³æ•ˆå·²é–‹" : "ğŸ”‡ éŸ³æ•ˆå·²é—œ";
    e.target.style.opacity = soundEnabled ? 1 : 0.7;
});

// æ‰‹å‹•ç™¼å°„å¹¾ç™¼åšé–‹å ´
setTimeout(launchManual, 500);
setTimeout(launchManual, 1200);

</script>
</body>
</html>
