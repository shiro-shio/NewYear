<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>2026 OBS Fireworks</title>
<style>
    /* é è¨­èƒŒæ™¯ç‚ºé€æ˜ï¼Œé€™å° OBS ä¾†èªªæ˜¯æœ€å®Œç¾çš„ */
    body { 
        margin: 0; 
        overflow: hidden; 
        background-color: transparent; /* é—œéµï¼šCSS èƒŒæ™¯é€æ˜ */
        font-family: 'Segoe UI', sans-serif; 
    }

    /* UI ä»‹é¢è¨­å®š */
    #ui-container {
        position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
        text-align: center; z-index: 100; pointer-events: none;
        color: rgba(255,255,255,0.9); text-shadow: 0 0 5px rgba(0,0,0,0.5);
        width: 90%;
    }
    #countdown { font-size: 3rem; font-weight: 200; letter-spacing: 2px; margin-bottom: 15px; font-variant-numeric: tabular-nums; }
    
    /* æ§åˆ¶é¢æ¿æ¨£å¼ */
    #controls { 
        pointer-events: auto; 
        background: rgba(0,0,0,0.5); /* åŠé€æ˜é»‘åº•è®“æŒ‰éˆ•çœ‹å¾—è¦‹ */
        backdrop-filter: blur(5px); 
        padding: 15px 20px; 
        border-radius: 20px; 
        display: inline-flex; 
        flex-wrap: wrap; 
        justify-content: center; 
        gap: 8px; 
        border: 1px solid rgba(255,255,255,0.15); 
    }
    
    button { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.5); color: white; padding: 8px 16px; border-radius: 20px; cursor: pointer; transition: all 0.2s; font-size: 0.9rem; white-space: nowrap; }
    button:hover { background: rgba(255,255,255,0.3); transform: translateY(-2px); }
    
    /* è®“ Canvas ä¿æŒåœ¨èƒŒæ™¯ */
    canvas { position: absolute; top: 0; left: 0; z-index: 1; pointer-events: none; }
</style>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>
</head>
<body>

<div id="ui-container">
    <div id="countdown">00:00:00</div>
    <div id="controls">
        <span style="display:block; width:100%; font-size:0.8rem; margin-bottom:5px; opacity:0.8;">OBS å°ˆç”¨æ§åˆ¶å°</span>
        <button onclick="cycleBackground()" style="background: #ff9800; border-color: #ff9800; color: black; font-weight: bold;">ğŸ¨ åˆ‡æ›èƒŒæ™¯ (ç›®å‰: é€æ˜)</button>
        
        <button onclick="launchManual('random')">ğŸš€ ç™¼å°„</button>
        <button onclick="launchManual('heart')">â¤ï¸ æ„›å¿ƒ</button>
        <button onclick="launchManual('ring')">ğŸª åœŸæ˜Ÿ</button>
        <button onclick="launchManual('text', '2026')">ğŸ“ 2026</button>
        <button onclick="toggleUI()">ğŸ‘ï¸ éš±è—UI</button>
    </div>
</div>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ==========================================
// 1. å ´æ™¯è¨­å®š (OBS å„ªåŒ–ç‰ˆ)
// ==========================================
const scene = new THREE.Scene();
scene.fog = null; // çµ•å°ä¸èƒ½æœ‰éœ§ï¼Œå¦å‰‡ç„¡æ³•å»èƒŒ

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
camera.position.set(0, 0, 160);
camera.lookAt(0, 40, 0);

const renderer = new THREE.WebGLRenderer({ 
    antialias: false, 
    powerPreference: "high-performance", 
    alpha: true // é—œéµï¼šé–‹å•Ÿ WebGL é€æ˜é€šé“
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;

// é è¨­ï¼šå®Œå…¨é€æ˜
renderer.setClearColor(0x000000, 0); 

document.body.appendChild(renderer.domElement);

const renderScene = new RenderPass(scene, camera);
// ç¢ºä¿ RenderPass ä¹Ÿæ˜¯æ¸…é™¤ç‚ºé€æ˜
renderScene.clearColor = new THREE.Color(0x000000);
renderScene.clearAlpha = 0; 

const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
bloomPass.strength = 2.2;
bloomPass.radius = 0.1;
bloomPass.threshold = 0.15;

const composer = new EffectComposer(renderer);
composer.addPass(renderScene);
composer.addPass(bloomPass);

// ==========================================
// èƒŒæ™¯åˆ‡æ›é‚è¼¯ (OBS ç¶ å¹•/é€æ˜/é»‘åº•)
// ==========================================
let bgMode = 0; // 0:é€æ˜, 1:ç¶ å¹•, 2:é»‘åº•
window.cycleBackground = () => {
    bgMode = (bgMode + 1) % 3;
    const btn = document.querySelector('button[onclick="cycleBackground()"]');
    
    if (bgMode === 0) {
        // --- é€æ˜æ¨¡å¼ (OBS æœ€ä½³) ---
        document.body.style.backgroundColor = 'transparent';
        renderer.setClearColor(0x000000, 0);
        renderScene.clearColor = new THREE.Color(0x000000);
        renderScene.clearAlpha = 0;
        btn.innerText = "ğŸ¨ åˆ‡æ›èƒŒæ™¯ (ç›®å‰: é€æ˜)";
        btn.style.backgroundColor = "#ff9800";
    } else if (bgMode === 1) {
        // --- ç¶ å¹•æ¨¡å¼ (è‰²éµå»èƒŒç”¨) ---
        // ä½¿ç”¨ç´”ç¶  #00FF00
        document.body.style.backgroundColor = '#00FF00';
        // WebGL å¿…é ˆæ¸²æŸ“å‡ºç¶ è‰²èƒŒæ™¯ï¼ŒAlpha è¨­ç‚º 1
        renderer.setClearColor(0x00FF00, 1);
        renderScene.clearColor = new THREE.Color(0x00FF00);
        renderScene.clearAlpha = 1;
        btn.innerText = "ğŸ¨ åˆ‡æ›èƒŒæ™¯ (ç›®å‰: ç¶ å¹•)";
        btn.style.backgroundColor = "#4CAF50";
    } else {
        // --- é»‘åº•æ¨¡å¼ (æ¿¾è‰²/è®Šäº®ç”¨) ---
        document.body.style.backgroundColor = '#000000';
        renderer.setClearColor(0x000000, 1);
        renderScene.clearColor = new THREE.Color(0x000000);
        renderScene.clearAlpha = 1;
        btn.innerText = "ğŸ¨ åˆ‡æ›èƒŒæ™¯ (ç›®å‰: é»‘åº•)";
        btn.style.backgroundColor = "#333";
    }
};

window.toggleUI = () => {
    const ui = document.getElementById('ui-container');
    ui.style.display = ui.style.display === 'none' ? 'block' : 'none';
};

// ==========================================
// 2. è³‡æºèˆ‡ç²’å­ (ç¶­æŒé«˜å“è³ª)
// ==========================================
function createGlowTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 64; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
    gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)'); 
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0,0,64,64);
    return new THREE.CanvasTexture(canvas);
}
const particleTexture = createGlowTexture();

function createTextPoints(text, size = 10) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 120;
    ctx.font = `bold ${fontSize}px "Microsoft JhengHei", Arial, sans-serif`;
    const textMetrics = ctx.measureText(text);
    canvas.width = textMetrics.width + 20; 
    canvas.height = fontSize * 1.5;
    ctx.font = `bold ${fontSize}px "Microsoft JhengHei", Arial, sans-serif`;
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, canvas.width / 2, canvas.height / 2);
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const points = [];
    const step = 5;
    for(let y = 0; y < canvas.height; y += step) {
        for(let x = 0; x < canvas.width; x += step) {
            if(data[(y * canvas.width + x) * 4 + 3] > 128) { 
                points.push({
                    x: (x - canvas.width / 2) * (size / fontSize),
                    y: -(y - canvas.height / 2) * (size / fontSize)
                });
            }
        }
    }
    return points;
}

// ==========================================
// 3. ç…™ç«ç³»çµ±
// ==========================================
const fireworks = [];
const trails = [];

class TrailParticle {
    constructor(pos, color) {
        this.pos = pos.clone();
        this.vel = new THREE.Vector3((Math.random()-0.5)*0.8, Math.random()*0.5, (Math.random()-0.5)*0.8);
        this.life = 1.0;
        this.decay = 0.02 + Math.random() * 0.02;
        this.color = color;
    }
    update() {
        this.pos.add(this.vel);
        this.life -= this.decay;
    }
}

class Firework {
    constructor(startX, targetY, type = 'sphere', textContent = '') {
        this.isDead = false;
        this.phase = 'launch';
        this.type = type;
        this.textContent = textContent;
        this.explosionScale = 1.0 + Math.random() * 1;
        const hue = Math.random() * 360;
        this.color = new THREE.Color().setHSL(hue/360, 1, 0.65);
        if (type === 'heart') this.color.setHex(0xff3366); 
        if (type === 'text') this.color.setHSL(45/360, 1, 0.7);

        this.pos = new THREE.Vector3(startX, -50, 0);
        this.vel = new THREE.Vector3(0, (Math.random() * 0.5 + 1.8), 0);
        this.targetY = targetY;
        
        const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0)]);
        const mat = new THREE.PointsMaterial({
            color: this.color, size: 3.5, map: particleTexture, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
        });
        this.rocket = new THREE.Points(geo, mat);
        this.rocket.position.copy(this.pos);
        scene.add(this.rocket);
        this.particles = null; 
    }

    update() {
        if (this.phase === 'launch') {
            this.pos.add(this.vel);
            this.rocket.position.copy(this.pos);
            this.vel.y *= 0.985;
            if (Math.random() > 0.1) trails.push(new TrailParticle(this.pos, this.color));
            if (this.vel.y < 0.3 || this.pos.y >= this.targetY) this.explode();
        } 
        else if (this.phase === 'explode') {
            const positions = this.geometry.attributes.position.array;
            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                positions[i3] += this.velocities[i3];
                positions[i3+1] += this.velocities[i3+1];
                positions[i3+2] += this.velocities[i3+2];
                this.velocities[i3+1] -= 0.02;
                this.velocities[i3] *= 0.90;
                this.velocities[i3+1] *= 0.90;
                this.velocities[i3+2] *= 0.90;
            }
            this.geometry.attributes.position.needsUpdate = true;
            this.material.opacity -= 0.011;
            if (this.material.opacity <= 0) {
                this.isDead = true;
                scene.remove(this.particles);
                this.geometry.dispose();
                this.material.dispose();
            }
        }
    }

    getShapePoints() {
        const points = [];
        const speed = 1.0 + Math.random() * 0.4;
        if (this.type === 'text') {
            createTextPoints(this.textContent, 25).forEach(p => points.push({ vx: p.x * 0.05, vy: p.y * 0.05, vz: (Math.random()-0.5)*0.5 }));
        } else if (this.type === 'heart') {
            for (let i=0; i<500; i++) {
                const t = (i/500)*Math.PI*2;
                const x = 16*Math.pow(Math.sin(t),3);
                const y = 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t);
                points.push({vx:(x/12)*speed, vy:(y/12)*speed, vz:(Math.random()-0.5)*0.5});
            }
        } else if (this.type === 'ring') {
            for (let i=0; i<400; i++) {
                const angle = (i/400)*Math.PI*2;
                points.push({vx:Math.cos(angle)*speed*2, vy:Math.sin(angle)*speed*0.1, vz:Math.sin(angle)*speed*2});
            }
        } else {
            for (let i=0; i<600; i++) {
                const theta = Math.random()*Math.PI*2, phi = Math.acos((Math.random()*2)-1), r = speed*(0.9+Math.random()*0.5);
                points.push({vx:r*Math.sin(phi)*Math.cos(theta), vy:r*Math.sin(phi)*Math.sin(theta), vz:r*Math.cos(phi)});
            }
        }
        return points;
    }

    explode() {
        this.phase = 'explode';
        scene.remove(this.rocket);
        const shapeData = this.getShapePoints();
        this.count = shapeData.length;
        this.geometry = new THREE.BufferGeometry();
        this.velocities = new Float32Array(this.count * 3);
        const positions = new Float32Array(this.count * 3);
        const colorsArr = new Float32Array(this.count * 3);

        for (let i = 0; i < this.count; i++) {
            positions[i*3] = this.pos.x; positions[i*3+1] = this.pos.y; positions[i*3+2] = this.pos.z;
            this.velocities[i*3] = shapeData[i].vx * this.explosionScale;
            this.velocities[i*3+1] = shapeData[i].vy * this.explosionScale;
            this.velocities[i*3+2] = shapeData[i].vz * this.explosionScale;
            const c = this.color.clone().offsetHSL(0, (Math.random()-0.5)*0.2, (Math.random()-0.5)*0.1);
            colorsArr[i*3] = c.r; colorsArr[i*3+1] = c.g; colorsArr[i*3+2] = c.b;
        }
        this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.geometry.setAttribute('color', new THREE.BufferAttribute(colorsArr, 3));
        this.material = new THREE.PointsMaterial({ size: 3.0 * this.explosionScale, map: particleTexture, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false });
        this.particles = new THREE.Points(this.geometry, this.material);
        scene.add(this.particles);
    }
}

const trailGeo = new THREE.BufferGeometry();
const trailMat = new THREE.PointsMaterial({ color: 0xffffff, size: 3.0, map: particleTexture, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false, vertexColors: true });
const trailMesh = new THREE.Points(trailGeo, trailMat);
scene.add(trailMesh);

function updateGlobalTrails() {
    for (let i = trails.length - 1; i >= 0; i--) {
        trails[i].update();
        if (trails[i].life <= 0) trails.splice(i, 1);
    }
    const positions = [], colors = [];
    trails.forEach(t => {
        positions.push(t.pos.x, t.pos.y, t.pos.z);
        const intensity = t.life * t.life; 
        colors.push(t.color.r * intensity, t.color.g * intensity, t.color.b * intensity);
    });
    trailGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    trailGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    trailGeo.attributes.position.needsUpdate = true;
    trailGeo.attributes.color.needsUpdate = true;
}

function animate() {
    requestAnimationFrame(animate);
    for (let i = fireworks.length - 1; i >= 0; i--) {
        fireworks[i].update();
        if (fireworks[i].isDead) fireworks.splice(i, 1);
    }
    updateGlobalTrails();
    composer.render();
}
animate();

window.launchManual = (type = 'random', text = '') => {
    let finalType = type;
    if (type === 'random') finalType = ['sphere', 'sphere', 'ring', 'heart'][Math.floor(Math.random()*4)];
    const x = (Math.random()-0.5)*250;
    const y = (finalType==='text'||finalType==='heart' ? 45:30) + Math.random()*200; 
    fireworks.push(new Firework(x, y, finalType, text));
};

const countdownEl = document.getElementById('countdown');
const targetDate = new Date(new Date().getFullYear()+1, 0, 1);
setInterval(() => {
    const now = new Date();
    const diff = targetDate - now;
    if (diff <= 0) { countdownEl.innerText = "2026"; return; }
    const h = String(Math.floor(diff/3600000)).padStart(2,'0');
    const m = String(Math.floor((diff%3600000)/60000)).padStart(2,'0');
    const s = String(Math.floor((diff%60000)/1000)).padStart(2,'0');
    countdownEl.innerText = `${h}:${m}:${s}`;
}, 1000);

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight); composer.setSize(window.innerWidth, window.innerHeight);
    bloomPass.resolution.set(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
