<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<title>2025 Anime Fireworks (Trails & Shapes)</title>
<style>
    body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
    #ui-container {
        position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
        text-align: center; z-index: 100; pointer-events: none;
        color: rgba(255,255,255,0.9); text-shadow: 0 0 10px rgba(255,255,255,0.5);
    }
    #countdown { font-size: 4rem; font-weight: 200; letter-spacing: 2px; margin-bottom: 10px; font-variant-numeric: tabular-nums; }
    #controls { pointer-events: auto; background: rgba(255,255,255,0.1); backdrop-filter: blur(8px); padding: 10px 20px; border-radius: 30px; display: inline-block; border: 1px solid rgba(255,255,255,0.2); }
    button { background: transparent; border: 1px solid rgba(255,255,255,0.4); color: white; padding: 5px 15px; border-radius: 15px; cursor: pointer; transition: 0.3s; margin: 0 5px; }
    button:hover { background: rgba(255,255,255,0.2); border-color: white; }
    .label { font-size: 0.8rem; margin-right: 10px; opacity: 0.8; }
</style>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>
</head>
<body>

<div id="ui-container">
    <div id="countdown">00:00:00</div>
    <div id="controls">
        <span class="label">2025 å‹•æ¼«é¢¨æ ¼ç…™ç«</span>
        <button onclick="launchManual('random')">ğŸš€ éš¨æ©Ÿç™¼å°„</button>
        <button onclick="launchManual('heart')">â¤ï¸ æ„›å¿ƒ</button>
        <button onclick="launchManual('text', '2025')">ğŸ”¢ 2025</button>
        <button onclick="launchManual('text', 'HAPPY')">âœ¨ HAPPY</button>
    </div>
</div>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// ==========================================
// 1. å ´æ™¯èˆ‡å¾Œè™•ç†è¨­å®š
// ==========================================
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x050505, 0.002);

const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 120);
camera.lookAt(0, 30, 0);

const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ReinhardToneMapping;
document.body.appendChild(renderer.domElement);

const renderScene = new RenderPass(scene, camera);
const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
bloomPass.strength = 2.5; 
bloomPass.radius = 0.5;
bloomPass.threshold = 0.1;

const composer = new EffectComposer(renderer);
composer.addPass(renderScene);
composer.addPass(bloomPass);

// ==========================================
// 2. è³‡æºç”Ÿæˆ
// ==========================================
function createGlowTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 32; canvas.height = 32;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
    gradient.addColorStop(0, 'rgba(255,255,255,1)');
    gradient.addColorStop(0.4, 'rgba(255,255,255,0.3)'); 
    gradient.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0,0,32,32);
    return new THREE.CanvasTexture(canvas);
}
const particleTexture = createGlowTexture();

// --- æ–‡å­—åº§æ¨™ç”Ÿæˆå™¨ ---
function createTextPoints(text, size = 10) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const fontSize = 100;
    canvas.width = fontSize * text.length; 
    canvas.height = fontSize * 1.5;
    
    ctx.font = `bold ${fontSize}px Arial`;
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(text, canvas.width / 2, canvas.height / 2);

    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const data = imageData.data;
    const points = [];
    
    // é™ä½æ¡æ¨£å¯†åº¦ä»¥æ¸›å°‘ç²’å­æ•¸
    const step = 4; 
    
    for(let y = 0; y < canvas.height; y += step) {
        for(let x = 0; x < canvas.width; x += step) {
            const index = (y * canvas.width + x) * 4;
            if(data[index + 3] > 128) { // å¦‚æœåƒç´ ä¸é€æ˜
                // å°‡ 2D åº§æ¨™è½‰æ›ç‚ºä»¥ä¸­å¿ƒç‚ºåŸé»çš„åº§æ¨™ï¼Œä¸¦ç¿»è½‰ Y è»¸
                points.push({
                    x: (x - canvas.width / 2) * (size / fontSize),
                    y: -(y - canvas.height / 2) * (size / fontSize)
                });
            }
        }
    }
    return points;
}

// ==========================================
// 3. ç³»çµ±æ ¸å¿ƒ
// ==========================================
const fireworks = [];
const trails = []; // å°ˆé–€å­˜æ”¾å°¾è·¡ç²’å­

// å°¾è·¡ç²’å­é¡åˆ¥ (Rocket Trail)
class TrailParticle {
    constructor(pos, color) {
        this.pos = pos.clone();
        this.vel = new THREE.Vector3((Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5, (Math.random()-0.5)*0.5);
        this.life = 1.0;
        this.decay = 0.03 + Math.random() * 0.03;
        this.color = color;
        this.size = 1.5 + Math.random();
    }
    update() {
        this.pos.add(this.vel);
        this.life -= this.decay;
    }
}

class Firework {
    constructor(startX, targetY, type = 'sphere', textContent = '') {
        this.isDead = false;
        this.phase = 'launch';
        this.type = type;
        this.textContent = textContent;
        
        // é¡è‰²è¨­å®š
        const hue = Math.random() * 360;
        this.color = new THREE.Color().setHSL(hue/360, 1, 0.6);
        if (type === 'heart') this.color.setHex(0xff3366); // æ„›å¿ƒå›ºå®šç²‰ç´…è‰²
        if (type === 'text') this.color.setHex(0xffaa00);  // æ–‡å­—å›ºå®šé‡‘é»ƒè‰²

        // å‡ç©ºè¨­å®š
        this.pos = new THREE.Vector3(startX, -40, 0);
        this.vel = new THREE.Vector3(0, (Math.random() * 0.5 + 1.5), 0);
        this.targetY = targetY;
        
        // ç«ç®­æœ¬é«”
        const geo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0)]);
        const mat = new THREE.PointsMaterial({
            color: this.color,
            size: 3.0,
            map: particleTexture,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        this.rocket = new THREE.Points(geo, mat);
        this.rocket.position.copy(this.pos);
        scene.add(this.rocket);
        
        this.particles = null; 
    }

    update() {
        if (this.phase === 'launch') {
            this.pos.add(this.vel);
            this.rocket.position.copy(this.pos);
            this.vel.y *= 0.985; // é‡åŠ›æ¸›é€Ÿ

            // --- ç”¢ç”Ÿå°¾è·¡ ---
            if (Math.random() > 0.2) {
                trails.push(new TrailParticle(this.pos, this.color));
            }

            // åˆ°é”é«˜åº¦æˆ–é€Ÿåº¦éæ…¢æ™‚çˆ†ç‚¸
            if (this.vel.y < 0.2 || this.pos.y >= this.targetY) {
                this.explode();
            }
        } 
        else if (this.phase === 'explode') {
            const positions = this.geometry.attributes.position.array;
            
            for (let i = 0; i < this.count; i++) {
                const i3 = i * 3;
                positions[i3] += this.velocities[i3];
                positions[i3+1] += this.velocities[i3+1];
                positions[i3+2] += this.velocities[i3+2];

                // ç‰©ç†æ¨¡æ“¬
                this.velocities[i3+1] -= 0.015; // é‡åŠ›
                this.velocities[i3] *= 0.94;    // ç©ºæ°£é˜»åŠ› (å‹•æ¼«æ„Ÿé—œéµï¼šå¿«é€Ÿæ¸›é€Ÿ)
                this.velocities[i3+1] *= 0.94;
                this.velocities[i3+2] *= 0.94;
            }
            
            this.geometry.attributes.position.needsUpdate = true;
            this.material.opacity -= 0.012; // æ¼¸éš±
            
            if (this.material.opacity <= 0) {
                this.isDead = true;
                scene.remove(this.particles);
                this.geometry.dispose();
                this.material.dispose();
            }
        }
    }

    getShapePoints() {
        const points = [];
        const speed = 0.8 + Math.random() * 0.5;

        if (this.type === 'text') {
            const rawPoints = createTextPoints(this.textContent, 15);
            // éš¨æ©Ÿæ‰“äº‚ä¸€é»é»ï¼Œæˆ–å¢åŠ ä¸€äº›è£é£¾é»
            rawPoints.forEach(p => {
                // æ–‡å­—ç…™ç«ä¸éœ€è¦å¤ªå¤§çš„æ“´æ•£é€Ÿåº¦ï¼Œå®ƒå€‘æ‡‰è©²å…ˆä¿æŒå½¢ç‹€ç„¶å¾Œè½ä¸‹
                points.push({
                    vx: p.x * 0.05, // ç¸®æ”¾åº§æ¨™ä½œç‚ºé€Ÿåº¦å‘é‡
                    vy: p.y * 0.05,
                    vz: (Math.random() - 0.5) * 0.1 // å¾®é‡ Z è»¸æ·±åº¦
                });
            });
            // å¢åŠ ä¸€äº›éš¨æ©Ÿçˆ†ç‚¸é»å¢åŠ è±å¯Œåº¦
            for(let i=0; i<100; i++) {
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * 2;
                points.push({ vx: Math.cos(angle)*r, vy: Math.sin(angle)*r, vz: (Math.random()-0.5)*2 });
            }
        }
        else if (this.type === 'heart') {
            // æ„›å¿ƒåƒæ•¸æ–¹ç¨‹
            for (let i = 0; i < 400; i++) {
                const t = (i / 400) * Math.PI * 2;
                // x = 16sin^3(t)
                const x = 16 * Math.pow(Math.sin(t), 3);
                // y = 13cos(t) - 5cos(2t) - 2cos(3t) - cos(4t)
                const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                
                // æ­¸ä¸€åŒ–ä¸¦ç¸®æ”¾
                points.push({
                    vx: (x / 16) * speed,
                    vy: (y / 16) * speed,
                    vz: (Math.random() - 0.5) * 0.2
                });
            }
        }
        else if (this.type === 'ring') {
            // åœŸæ˜Ÿç’°/åœ“ç’°
            for (let i = 0; i < 300; i++) {
                const angle = (i / 300) * Math.PI * 2;
                points.push({
                    vx: Math.cos(angle) * speed * 1.5,
                    vy: Math.sin(angle) * speed * 0.2, // å£“æ‰ Y è»¸
                    vz: Math.sin(angle) * speed * 1.5
                });
            }
            // åŠ ä¸Šä¸­é–“çš„ä¸€é¡†çƒ
            for (let i=0; i<100; i++) {
                 const theta = Math.random() * Math.PI * 2;
                 const phi = Math.acos((Math.random() * 2) - 1);
                 const r = speed * 0.5;
                 points.push({
                     vx: r * Math.sin(phi) * Math.cos(theta),
                     vy: r * Math.sin(phi) * Math.sin(theta),
                     vz: r * Math.cos(phi)
                 });
            }
        }
        else {
            // é è¨­çƒé«” (Sphere)
            const count = 400;
            for (let i = 0; i < count; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                const r = speed * (0.8 + Math.random() * 0.4); 
                points.push({
                    vx: r * Math.sin(phi) * Math.cos(theta),
                    vy: r * Math.sin(phi) * Math.sin(theta),
                    vz: r * Math.cos(phi)
                });
            }
        }
        return points;
    }

    explode() {
        this.phase = 'explode';
        scene.remove(this.rocket);

        const shapeData = this.getShapePoints();
        this.count = shapeData.length;
        
        this.geometry = new THREE.BufferGeometry();
        this.velocities = new Float32Array(this.count * 3);
        const positions = new Float32Array(this.count * 3);
        const colorsArr = new Float32Array(this.count * 3);

        for (let i = 0; i < this.count; i++) {
            positions[i*3] = this.pos.x;
            positions[i*3+1] = this.pos.y;
            positions[i*3+2] = this.pos.z;

            this.velocities[i*3] = shapeData[i].vx;
            this.velocities[i*3+1] = shapeData[i].vy;
            this.velocities[i*3+2] = shapeData[i].vz;

            // è®“é¡è‰²ç¨å¾®æœ‰è®ŠåŒ–
            const c = this.color.clone().offsetHSL(0, 0, (Math.random()-0.5)*0.2);
            colorsArr[i*3] = c.r;
            colorsArr[i*3+1] = c.g;
            colorsArr[i*3+2] = c.b;
        }

        this.geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.geometry.setAttribute('color', new THREE.BufferAttribute(colorsArr, 3));

        this.material = new THREE.PointsMaterial({
            size: this.type === 'text' ? 2.5 : 3.0,
            map: particleTexture,
            vertexColors: true,
            transparent: true,
            opacity: 1,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        this.particles = new THREE.Points(this.geometry, this.material);
        scene.add(this.particles);
    }
}

// ==========================================
// 4. å…¨åŸŸ Trail æ¸²æŸ“ (å–®ä¸€æ‰¹æ¬¡å„ªåŒ–)
// ==========================================
// ç‚ºäº†æ•ˆèƒ½ï¼Œé€™è£¡æˆ‘å€‘ç”¨ä¸€å€‹ç°¡å–®çš„å…±äº«å¹¾ä½•é«”ä¾†æ¸²æŸ“æ‰€æœ‰å‡ç©ºè»Œè·¡
const trailGeo = new THREE.BufferGeometry();
const trailMat = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 2.0,
    map: particleTexture,
    transparent: true,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    vertexColors: true
});
const trailMesh = new THREE.Points(trailGeo, trailMat);
scene.add(trailMesh);

function updateGlobalTrails() {
    // ç§»é™¤æ­»æ‰çš„ trail
    for (let i = trails.length - 1; i >= 0; i--) {
        trails[i].update();
        if (trails[i].life <= 0) trails.splice(i, 1);
    }

    // é‡å»º Buffer
    const positions = [];
    const colors = [];
    
    trails.forEach(t => {
        positions.push(t.pos.x, t.pos.y, t.pos.z);
        // é¡è‰²éš¨å£½å‘½è®Šæ·¡
        colors.push(t.color.r, t.color.g, t.color.b); 
    });

    trailGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    trailGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
    // æ‰‹å‹•è™•ç† opacity æ¯”è¼ƒéº»ç…©ï¼Œé€™è£¡ç°¡å–®åˆ©ç”¨ color çš„é»‘ç™½æ··åˆæˆ–è®“ bloom è™•ç†
    // æ›´å¥½çš„åšæ³•æ˜¯åœ¨ shader è£¡è™•ç† alphaï¼Œä½†é€™é‚Šç°¡åŒ–è™•ç†ï¼š
    // æˆ‘å€‘å¯ä»¥å°‡é¡è‰²ä¹˜ä»¥ life ä¾†æ¨¡æ“¬ fade out
    const colorsAttr = trailGeo.attributes.color.array;
    for(let i=0; i<trails.length; i++){
        colorsAttr[i*3] *= trails[i].life;
        colorsAttr[i*3+1] *= trails[i].life;
        colorsAttr[i*3+2] *= trails[i].life;
    }
    trailGeo.attributes.color.needsUpdate = true;
}

// ==========================================
// 5. å‹•ç•«è¿´åœˆ
// ==========================================
function animate() {
    requestAnimationFrame(animate);
    
    // æ›´æ–°ç…™ç«
    for (let i = fireworks.length - 1; i >= 0; i--) {
        fireworks[i].update();
        if (fireworks[i].isDead) {
            fireworks.splice(i, 1);
        }
    }
    
    // æ›´æ–°è»Œè·¡
    updateGlobalTrails();

    composer.render();
}
animate();

// ==========================================
// 6. äº’å‹•èˆ‡å€’æ•¸é‚è¼¯
// ==========================================
window.launchManual = (type = 'random', text = '') => {
    let finalType = type;
    if (type === 'random') {
        const types = ['sphere', 'sphere', 'ring', 'heart'];
        finalType = types[Math.floor(Math.random() * types.length)];
    }

    const x = (Math.random() - 0.5) * 60;
    // æ–‡å­—ç…™ç«æ‰“é«˜ä¸€é»ï¼Œé¿å…è¢«é®æ“‹
    const y = finalType === 'text' ? 35 : 20 + Math.random() * 20; 
    
    fireworks.push(new Firework(x, y, finalType, text));
};

let autoInterval = null;
const countdownEl = document.getElementById('countdown');
const targetDate = new Date(new Date().getFullYear() + 1, 0, 1);

function startAutoFire() {
    if(autoInterval) return;
    autoInterval = setInterval(() => {
        const r = Math.random();
        if (r > 0.9) launchManual('text', '2025');
        else if (r > 0.8) launchManual('heart');
        else launchManual('random');
    }, 1200);
}

function updateCountdown() {
    const now = new Date();
    const diff = targetDate - now;
    if (diff <= 0) {
        countdownEl.innerText = "2025 HAPPY NEW YEAR";
        startAutoFire();
        return;
    }
    const h = String(Math.floor(diff / 3600000)).padStart(2, '0');
    const m = String(Math.floor((diff % 3600000) / 60000)).padStart(2, '0');
    const s = String(Math.floor((diff % 60000) / 1000)).padStart(2, '0');
    countdownEl.innerText = `${h}:${m}:${s}`;
}
setInterval(updateCountdown, 1000);

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
});

// é–‹å ´ç§€
setTimeout(() => launchManual('text', '2025'), 500);
setTimeout(() => launchManual('heart'), 1500);

</script>
</body>
</html>
